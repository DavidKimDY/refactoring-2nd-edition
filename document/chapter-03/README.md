# 코드에서 나는 악취 

켄트 백 할머님의 원칙 `냄새 나면 당장 갈아라.`

이제 리팩토링을 어떻게 작동하는지 감이 왔을 것이다. 

하지만 리팩토링 적용 방법을 아는 것과 제때 적용할 줄 아는 것은 다르다. __(제때 적용하는 것에 대해서 3의 법칙을 설명하지 않았나? 그리고 기능 추가전에 코드를 분석해보면서 더 좋은 구조로 만들고 하라고 했었다고도 했고, 애초에 수시로 리팩토링을 하라고 했었던것 같다. 
이렇게 설명을 해줬는데 리팩토링을 어느 시점에 적용해야 하는 지에 대해서 이 챕터에서 조금 더 자세하게 다루는 것인가?)__

리팩토링을 언제 시작하고 언제 끝내는 지를 아는 것도 매우 중요하다. 

여기서 딜레마는 리팩토링의 기법 중 인스턴스 변수를 삭제하고 상속 계층을 만드는 것을 설명하기는 쉽지만 이런 일들을 `언제 적용 하는지` 에 대한 명확한 규칙은 없다.

나 같은 경우는 프로그래밍의 미학이라는 애매모호한 개념에 기대서 이유를 설명하는 경우가 많은데 이도 적합 하지는 않다. 

그러므로 구체적인 적용 시점에 대해 논의를 해보자. 

이 책의 초판을 집필히면서 켄트 백을 만나러 갔었는데 그 당시의 켄트 백은 갓 태어난 딸을 돌보고 있었다. 

딸의 기저귀 냄새에 민감했던 켄트 백은 이 경험을 빗대어서 리팩토링을 적용할 시점을 __악취__ 라는 표현으로 설명을 했다.

그렇다면 __냄새___ 라은 표현이 __미학__ 이라는 표현보다 나은가? 라고 물으면 그렇다. 

나와 켄트는 수 많은 프로젝트를 경험하면서 많은 코드를 봐왔다. 

그 과정 속에서 __리팩토링이 필요한 코드들은 일정한 패턴이 있다라는 사실을 발견했다.__ __(이 부분이 힉샘이겠네. 이 패턴을 기점으로 리팩토링을 언제 적용하면 되는지 기준을 세우면 되겠다.)__ 

(이 장에서는 켄트와 내가 같이 작업을 한 것이므로 우리라는 표현을 사용하겠다.)

하지만 리팩토링을 언제 멈춰야 하는지에 대한 정확한 기준을 세우지는 않을 것이다.

왜냐하먼 __우리 경험상 숙련된 프로그래머의 경험만큼 정확한 기준은 없기 때문이다.__ __(이게 이유구나. 그냥 자신이 할 수 있는 역량만큼. 그리고 개발 일정에 맞춰서. 라는 기준이 중요하지 않나 라는 생각이 든다. 내가 생각할 때 이 정도의 리팩토링 기법을 적용할 수 있겠지만 그러면 너무나 많은 일정이 소요되므로 구조만 바꿔 놓는다던지. )__

인스턴스 변수는 몇 개가 적당한지, 메소드는 몇 줄이 적당한지 등을 감을 통해서 늘려나가야 한다. __(그리고 애초에 좋은 코드의 기준이라는 게 클린 코드에서 있으니까. 이것들을 기준으로 삼으면 되겠네.)__

__(코드 퀄리티의 어느 정도의 끝은 존재하니까. 이거 기준으로 이것을 넘도록 하지는 않으면 되겠다. 한계치를 정하는 거지. YAGNI 라는 원칙을 적용한다고 생각해보면 되겠다.)__

어떤 리팩토링 기법을 적용해야 할 지 모르겠다면 이 장의 내용과 함께 부록B 의 내용을 참고해보자. __(부록의 내용을 봤는데 해당 악취에 따른 적용할 수 있는 기법이 매핑되어 있다. 해당 기법의 이름만 보고도 어떤 기법인지 명확하게 정리할 수 있어야 한다고 생각했고 얻는 이점과 놓치는 이점에 대해서도 정리가 필요하다고 생각한다.)__

***

## 3.1 기이한 이름 (Mysterious Name)

추리 소설이라면 무슨 일이 전개되는지 궁금 할 수 있지만 코드에선 아니다. 

코드는 단순하고 명료해야한다. __(이게 코드의 본질적인 목적이라고 생각한다.)__

__코드를 명료하게 표현하는데 가장 크게 기여하는 것 중 하나는 이름이다.__

그래서 함수, 모듈, 변수, 클래스 이름만 보고도 무슨 일을 하는지 어떻게 사용하는지를 명확히 알 수 있어야 한다. __(무슨 일을 하는지에 대해서는 늘 생각을 하는데 어떻게 사용하는지도 이름만 보고 알 수 있을까? 에 대한 고민은 크게 안했던 것 같다. 이것도 체크 리스트 중 하나.)__

하지만 이름 짓기는 프로그래밍에서 가장 어렵다고 알려진 두 가지 방법 중 하나다. __(나머지 하나는 캐시 무효화다.)__

그 때문에 우리가 자주 사용하는 리팩토링도 __함수 선언 바꾸기__, __변수 이름 바꾸기__, __필드 이름 바꾸기__ 같은 리팩토링이다.

이름 바꾸기는 단순히 표현을 위한 방법이 아니다. __이름은 명확하게 무엇인지 드러내는 것으로 명확한 이름이 떠오르지 않는다면 설계가 잘못된 것일 수도 있다.__ 이를 명심해두자.

***

## 3.2 중복 코드 (Duplicated Code)

똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합해서 더 나은 프로그램으로 변경 할 수 있다. __(엔지니어링 원칙 DRY. 변경 포인트를 하나로 바꾸도록 하는 것.)__ 

중복 코드를 해결 할 땐 서로 차이점이 없는지 살펴보는게 중요하다. __(차이점이 있다면 이를 해결하는 디자인 패턴의 방법으로 템플릿 메소드 패턴, 전략 패턴. 등이 있다.)__

가장 간단한 코드 중복의 예로 하나의 클래스 안에서 두 메소드가 똑같은 표현을 한다면 __함수 추출하기__ 를 적용할 수 있다. 

코드가 비슷한데 완적 똑같지는 않다면 __문장 슬라이스__ 로 비슷한 부분을 모우고 __함수 추출하기__ 로 빼낼 수 있다. 

같은 부모로 부터 파생된 서브 클래스에서 중복된 메소드가 있다면 각자 따로 만드는게 아니라 부모의 메소드를 통해서 호출하도록 하는 __메소드 올리기__ 방법도 있다. 

***

## 3.3 긴 함수 (Long Function)

우리의 경험에 비추어보면 오랜 기간 잘 활용되는 함수들은 대체로 길이가 짧았다. __(함수의 재사용성 측면을 본 것인듯. 긴 함수는 대체로 특정한 일을 위해 작성된 경우가 많으니까. 재사용 되기는 힘들겠지. 그렇다면 긴 함수를 짧은 함수의 조합으로 구성된다면? )__

짦은 함수들로 구성된 코드베이스를 훑어보면 __자기가 계산하는 구조보다 위임하는 구조로 보인다.__ 

이런 위임하는 구조는 코드를 이해하고 공유하기 쉽다. 

짧은 함수로 만든다는 건 하나의 긴 함수처럼 모든 계산을 하는 것이 아니라 짧은 함수 여러개를 호출하는 구조이다. 

이런 구조 때문에 성능 상으로 떨어진다는 생각을 할 수 있지만 요즘 프로그래밍 언어에서 이는 문제가 되지 않는다. 

그리고 __짧은 함수와 좋은 이름의 조합__ 은 짧은 함수의 구현을 보지 않아도 어떠한 일을 하는지 명확하게 알 수 있어서 코드를 이해하기가 훨씬 쉬어진다. 

이를 위해서는 함수 자체를 적극적으로 짧게 구성하도록 해야한다.

긴 함수에서 우리가 주석으로 달아야 하는 부분이 있다면 그 부분은 함수로 빼내자. __(적용 기법.)__

그리고 __그 함수의 이름은 동작 방식에 집중하지 말고 의도에 집중하자.__ __(주석도 의도가 중요하죠.)__

__함수의 이름은 의도가 중요하고 이 의도와 실제 구현과의 괴리감이 얼마나 있느냐가 잘 짓는 기준이다.__

즉 __무엇을 하는지 설명해주지 못한다면 함수의 이름을 잘 지은게 아니다.__

함수를 짧게 만드는 방법의 99% 는 __함수 추출하기__ 로 이뤄진다.

함수가 매개변수와 임시 변수를 많이 사용한다면 추출하기 어렵다.

많은 임시 변수는 __임시 변수를 질의 함수로 바꾸기__ 기법을 사용하면 되고 많은 매개변수는 __매개 변수를 매개변수 객체 만들기__ 와 __객체 떠넘기기__ 에 집중한다. __(요즘 객체를 만들때 SOLID 원칙의 S 와 D 를 많이 신경쓰는게 중요하다고 생각한다.)__

이런 리팩토링 기법을 적용해도 여전히 임시 변수와 매개 변수가 많다면 __함수를 명령으로 만들기__ 기법을 사용해도 좋다.

조건문이나 반복문도 추출의 대상이 된다.

__조건문 분해하기__ 로 대응하거나 switch 문을 구성하는 case 문 마다에 있는 내용을 함수로 추출하는 __함수 추출하기__ 를 사용하거나 같은 조건을 기준으로 나뉘는 switch 문이 여러개라면 __조건문을 다형성으로 바꾸기__ 를 적용하면 된다.

반복문도 그 안의 코드와 함께 추출해서 함수로 만드는 것도 가능하다. 

__추출한 반복문에 마땅한 이름이 떠오르지 않는다면 성격이 다른 두 가지의 일을 하는 것일 수도 있다.__

이는 __반복문 쪼개기__ 를 사용하자.

***

## 3.4 긴 매개변수 목록 (Long Parameter List)

우리가 프로그래밍을 시작하는 시절에는 함수에 필요한 모든 데이터를 함수 파라미터로 넘기라는 말을 들었다. 

그래야 암적 존재인 전역 데이터의 사용을 줄일 수 있기 때문이다. 

하지만 매개변수의 목록이 길어지면 그 자체로 이해하기 어렵다. 

종종 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있다면 이런 매개변수는 __매개 변수를 질의 함수로 바꾸기__ 를 적용할 수 있다. __(뭔 뜻이지?)__ 

사용 중인 데이터 구조에서 값들을 각각 뽑아서 매개변수로 넘기는 구조라면 __객체 통째로 넘기기__ 를 적용할 수 있다. 

항상 함께 전달되는 매개변수들이 있다면 이들을 묶는 방법인 __매개변수 객체로 만들기__ 를 적용할 수 있다. 

함수의 동작을 제어하는 플래그 역할을 하는 매개변수는 __플래그 인수 제거하기__ 로 없애 줄 수 있다. 

__클래스를 통해서 매개변수를 줄일 수 있다.__ 만약에 여러 함수에서 공통적으로 사용하는 파라미터들이 있다면 이를 하나의 클래스 안으로 옮기면 파라미터 자체를 많이 줄일 수 있다.

이 기법은 __여러 함수를 클래스로 옮기기__ 기법을 통해서 가능하다.

***

## 3.5 전역 데이터 (Global Data)

전역 데이터를 주의해야 한다는 점은 우리가 소프트웨어 개발을 처음 배우기 시작할 때부터 들었다.

전역 데이터를 악취 중에 가장 독한 악취 중의 하나다.

전역 데이터가 악취인 이유는 코드 베이스 어디에서나 변경이 가능하니까 이 변경 시점을 추적하는게 힘들기 때문이다. 

그래서 버그는 끊임없이 발생하는데 이 원인이 되는 코드를 찾기가 힘들다. 

전역 데이터의 대표적인 형태는 클래스 전역 변수와 싱글톤 객체가 있다.

이를 방지하기 위해 우리가 자주 사용하는 방법은 __변수 캡슐화하기__ 이다. 

이를 통해 접근 포인트를 제어할 수 있다. 같은 패키지 내에서만 접근할 수 있도록 한다던지.

전역 데이터는 가변일 때 특히나 더 까다롭고 변견되지 않느다고 하면 그나마 안전한 편이다.

***

## 3.6 가변 데이터 (Mutual Data)

데이터를 변경했더니 예상치 못한 결과로 이어지는 경우가 종종 있다.

이런 문제는 아주 드물게 발생하지만 만약에 발생한다면 이를 찾기는 굉장히 어렵다. 

이러한 이유로 함수형 프로그래밍에서는 데이터를 변경하지 않고 변경하는 경우라면 원래의 데이터의 복제본을 만들어서 사용하는 경우가 많다.

하지만 함수형 프로그래밍 자체를 사용하는 경우도 적고 변수 바꾸기를 지원하는 언어는 많다. 

그렇다고 해서 불변성이 주는 장점을 포기할 필요는 없고 불변성을 주는 방법은 다양하게 있다.

가령 __변수 캡슐화하기__ 를 통해서 정해놓은 함수를 거쳐서만 변수에 접근할 수 있도록 하는 방법이 있다. 이를 통해 변수의 수정 포인트를 제한할 수 있고 수정되는 과정을 디버깅 하기도 쉽다. 

하나의 번수에 용도가 다른 값들을 매번 갱신하는 경우가 있다면 __변수 쪼개기__ 를 통해서 독립된 변수로 만들어서 갱신되는 변수만 따로 고립시켜 놓는 방법도 있다. 

이를 통해 갱신이 될 수 있는 변수만 따로 빼냈기 때문에 문제를 해결하기가 더 쉬워진다. __(갱신되는 변수를 다른 코드로 분리시켜 놨으니 추적하기가 쉬워진다.)__

그리고 갱신 로직 자체를 별도의 다른 메소드로 빼내서 코드를 분리하는 기법도 있다. 이는 __함수 추출하기__ 와 __문장 슬라이스하기__ 기법을 통해서 가능하다.

API 를 만들 때는 __질의 함수와 변경 함수 분리하기__ 를 구별시켜 놓는게 좋다. __(이렇게 분리시켜 놓는 이유가 뭐였지? 역할이 넘 큰 탓인가? 클린 코드에서 본 것 같은데)__

그리고 __세터 제거하기__ 를 통해서 애초에 변경될 여지를 막아놓는 것도 좋다. __(애초에 변경될 여지를 막는 것이니.)__

__값을 다른 곳에서 설정할 수 있는 가변 데이터가 풍기는 악취는 고약하다.__ __(이런것 같은데 다른 서비스에서 그 객체를 분해해서 설정하는 것. 메소드를 통해 행동시키는게 아니라.)__

이럴 때는 __파생 변수를 질의 함수로 바꾸기__ 를 이용해 코드 전체에 골고루 뿌려준다. 

변수의 유효 범위가 넓어질수록 위험도 덩달아 커진다. __(변수를 바꿀 수 있는 범위를 말하는 듯. 특정 범위에서만 바꿀 수 있도록 하면 그렇게 큰 문제가 아니듯.)__

따라서 __여러 함수를 클래스로 묶기__ 나, __여러 함수를 변환 함수로 묶기__ 를 활용해서 특정 변수를 갱신하는 코드를 제한시켜 놓는게 좋다. 

구조체처럼 내부 필드에 데이터를 담고 있는 구조라면 일반적으로 __참조를 값으로 바꾸기__ 를 적용해 내부 필드를 수정하지 말고 구조체를 통째로 교체하는 편이 좋다. __(뭔 뜻이지?)__

***

## 3.7 뒤엉킨 변경 (Divergent Change)

우리는 소프트웨어를 변경하기 쉬운 구조로 바꾼다.

이 말은 변경 포인트를 한 군데로 고립시킨다는 말을 뜻한다. 

이렇게 할 수 없다면 뒤엉킨 변경과 산탄총 수술 중 하나 때문에 그렇다. __(두 패턴 모두 악취를 말한다.)__

뒤엉킨 변경은 SRP 가 제대로 지켜지지 않을 때 발생하는 원칙이다. 

즉 하나의 모듈이 여러 가지 원인 때문에 변경될 때를 말한다. 

예컨대 하나의 기능을 지원하기 위해 고쳐야 하는 메소드가 여러 군데라면 이는 뒤엉킨 변경이 발생한 것이다. 

예를 들어 새로운 데이터베이스를 지원하려고 하는데 함수 세 개를 바꿔야하고, 금융상품이 하나씩 추가될 때마다 또 다른 함수 네 개를 바꿔야 한다면 이는 뒤엉킨 변경이 발생한 것이다. 

데이터베이스 연동과 금융 상품 처리는 다른 __맥락__ 에서 이뤄지므로 독립된 모듈로 분리되어 있어야 한다. __(맥락별로 모듈을 만들어 놓는게 중요하다고 생각한다. 이런 모듈을 잘 만드는게 SRP 를 지키는게 아닐까.)__

그래야 무언가를 수정할 때 해당 맥락의 코드만 봐도 진행하는게 가능하다. 

데이터베이스에서 데이터를 가져오고 금융 상품에서 처리하는 구조로 맥락이 잡혀 있다면 이렇게 맥락을 분리하기 위해서 단계를 분리하는 __단계 쪼개기__ 기법을 적용하는게 좋다. 

전체 처리 과정에서 각기 다른 맥락의 함수를 호출하고 있다면 맥락을 가진 모듈을 만들어주고 관련 함수들을 모우는 __함수 옮기기__ 기법을 사용하는게 좋다. 

이때 여러 맥락을 드나드는 함수가 있다면 이를 분리시키기 위해 __함수 추출하기__ 기법을 사용한다. 

모듈이 클래스 단위라면 __클래스 추출하기__ 기법이 맥락별로 분리하는데 기여해줄 것이다. 

***

## 3.8 산탄총 수술 (Shotgun Surgery)

산탄총 수술은 뒤엉킨 변경과 비슷하면서도 정반대다. __(무슨 뜻? 아. 산탄총 수술은 흩어진 맥락을 모우는 용도. 뒤엉킨 변경은 하나의 거대한 맥락을 작은 맥락으로 나누는 용도.)__

이 냄새는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다.

변경할 부분이 코드 전반에 흩어져 있다면 찾기가 어렵다. 그리고 수정할 부분을 놓치기 쉽다  __(변경 포인트를 제한하라 라는 뜻 같은데)__

이럴 때는 함께 변경되는 대상들을 __함수 옮기기__ 와 __필드 옮기기__ 로 모두 한 모듈로 묶어두는게 좋다. 

비슷한 데이터를 다루는 함수가 많다면 __여러 함수를 클래스로 옮기기__ 기법을 통해서 모듈로 만들 수 있다. 

구조를 변환하거나 보강하는 함수들이 많다면 __여러 함수를 변환 함수로 묶기__ 를 적용하면 된다. __(이게 뭐지)__

이렇게 묶은 함수들을 다음 단계로 전달하는 구조라면 __단계 쪼개기__ 를 적용하면 된다. 

어설프게 분리된 로직을 __함수 인라인 하기__ 나 __클래스 인라인 하기__ 와 같은 리팩토링 기법을 적용하는 것도 좋다.

*** 

 
  

  


 


***



# 3. 코드에서 나는 악취 Review

여기서 정리할 땐 코드에서 나는 악취를 정의하고 해결할 수 있는 기법들을 내 나름대로 정리해서 익히는게 중요하다고 생각한다.

이 말은 접근 방식을 정의한다는 말이다. 

결국에 이 챕터의 목적 자체는 악취를 느끼고 해결하라는 내용이니까.

악취라는 말은 뭘까? 수 많은 코드를 보면서 안좋은 코드들을 특정 패턴으로 나눈것들을 말한다.
 
그래서 리팩토링을 적용을 했어. 그러면 리팩토링의 끝나는 시점은 언제인가? 라는 질문에는 감을 통해서 익혀나가야 한다고 하는데 최종 지점은 클린 코드라고 생각이 들었다.

클린 코드에서 나온 여러가지 룰들을 기반으로 나누면 되지 않을까? 

그렇다면 클린 코드의 룰에선 어떤게 있었을까? __(클린 코드 책을 보면서 좀 더 정리하는게 필요해보인다.)__

***

## 3.1 기이한 이름 (Mysterious Name)

이름익 가지는 위대함은 다 아니까

무슨 일을 하는지 모르겠는 이름을 보면 (이런 악취를 맡으면)

이름을 바꿔라 라는 내용이다. 

그래서 그와 관련된 기법을 소개한다. 

- 함수 선언 바꾸기 (6.5절) 

- 변수 이름 바꾸기 (6.7절)

- 필드 이름 바꾸기 (9.2절) 

그리고 부수적으로 정확한 이름이 떠오르지 않는다면 설계를 한번 의심해보라 라는 조언이 있었다. 

***

## 3.2 중복 코드 (Duplicated Code)

중복 코드가 악취인 건 다들 알거라고 생각한다. 

변경 포인트가 많아지니까 수정이 어려워진다는 악취

이를 해결하는 방법은 중복 코드를 추상화해서 재사용하는 방식이 있겠다. 

- 함수 추출하기 (6.1절) 을 이용해서 같은 로직을 빼내는 방법. 

- 함수 추출하기 응용으로 이제 문장 슬라이스 (8.6절) 를 이용해서 관련 코드를 모운 다음에 함수 추출하기 이용하는 것. 

- 여러가지 디자인 패턴 이용하기 (템플릿 메소드 패턴과 전략 패턴 등)

디자인 패턴을 좀 더 자세하게 보면 다음과 같을 수 있겠다. 

전략패턴이 중복 코드를 어떻게 지울 수 있을까? 전략 패턴을 안쓰면 생길 수 있는 코드 예 중에 이제 하나의 인터페이스와 여러개의 구현 객체가 있따고 생각했을떄

특정한 몇개의 구현 객체는 로직이 비슷해. 그렇다고 모든 구현객체가 가지는 공통 사항은 또 아니야. 이 경우 구현 객체의 로직을 전략 패턴으로 뺴면 되겠다. 

***

## 3.3 긴 함수 (Long Function)

이 악취가 내뿜는건 아주 구체적인 일을 한다는 측면에서 내뿜는 악취다.

하나의 함수에서 모든 걸 처리하니까 아주 구체적인 일을 할 것이고 이를 통해 재사용성이 떨어질 것이고 코드를 이해하기 어려울 것이다.

이 함수에서 모든 걸 하니까 다른 객체와 협력하는 구조가 아닐 것이고 (자기가 계산을 하는게 아닌 위임을 하는 것)

그래서 함수를 짧게 만들어야 한다. 

이를 위한 방법은 다음과 같다. 

- 함수를 짧게 만드는 방법은 함수를 추출하는 것이다. (6.1절)

  - 이렇게 추출하는 근간이 되는 원칙은 주석이 달만한가? 를 기준으로 세우면 된다. 주석이 달릴만하다 라는 건 그 부분이 어떠한 의도를 가지고 있다는 뜻이므로.
  
  - 임시 변수가 많으면 함수를 추출하기 어렵다. 그러므로 임시 변수를 질의 함수로 바꿔야한다. (7.4절)
  
  - 함수를 추출할 때 많은 매개 변수를 던진다면 매개 변수 객체 만들기를 이용하자. (6.8절) 그리고 객체 떠넘기기를 이용하자. (11.4절)
  이래도 매개변수가 많다면 함수를 명령으로 만들기 (11.9절) 을 이용하자. 

  - 조건문도 추출의 대상이 될 수 있다. 조건물 분해하기 (10.1절) 을 통해서 
  
  - Switch 문도 마디마다 함수로 추출하는게 가능하다.
  
  - Switch 문도 여러개라면 조건문을 다형성으로 바꾸기 (10.4절) 을 이용하는 것도 가능하다.  
  
  - 반복문도 여러번 돌더라도 같은 일을 하는 것끼리 묶는 반복문 쪼개기 (8.7절)을 사용하는 게 가능하다. 

***

## 3.4 긴 매개변수 목록 (Long Parameter)

매개변수가 길면 코드를 이해하기 어렵다는 악취 

매개변수는 하나일때가 가장 좋고 3개를 넘기지 말아라.

매개변수까지 고려해서 함수의 이름을 지으라는 말이 있었던 걸로 기억한다. 

해결하는 방법은 다음과 같다. 

- 하나의 매개변수를 통해서 다른 매개변수를 구하는 매개 변수를 질의 함수로 바꾸기 (11.5절)

- 매개 변수 자체를 줄이기 위해 매개변수를 객체로 만들기 (6.8절)

- 매개변수로 넘기는 형태가 하나의 데이터 구조에서 값들을 각각 뽑아서 던지는 형태라면 객체 통째로 넘기기 (11.4절)

***

## 3.5 전역 데이터 (Global Data)

전역 데이터 자체가 악취를 풍긴다. 

이유로는 어디서든 가져와서 변경할 가능성이 있기 떄문에 예상치 못한 결과가 나올 가능성이 있다는 점. 

즉 변경할 가능성이 없다면 고려해야 하는 사항으로는 메모리를 쓴다라는 것. 

GC 가 더 자주 일어나도록 만든다는 것. 이 점을 위주로 생각해보면 될 듯. 

이 문제를 해결하는 방법은 간단하다.

- 어디서든 접근하지 못하게 변수 캡술화 하기 (6.6절) 을 통해서 접근 제한을 거는 것. 뭐 같은 패키지 내에서만 접근이 가능하도록 한다던지.

***


## 3.6 가변 데이터 (Mutable Data)

이 악취도 전역 데이터와 유사하다. 데이터 변경으로 인해 예상치 못한 결과가 나올 수 있다라는 점. 

이를 해결하는 방법은 다음과 같다. 

- 먼저 어디서든 변경하지 못하도록 접근 제어를 거는 것 이는 변수 캡슐화 하기 (6.6절) 기법을 통해서 가능하다. 

- 하나의 변수가 다른 용도로도 사용되고 있다면 새로운 변수를 만들어서 안전하게 만드는 방법인 변수 쪼개기 (9.1절)이 있다. 

- 변경을 하는 부분만 따로 빼내는 방법도 있다. 함수 추출하기 (6.1절) 기법을 통해서. 이는 클맄 코드에 변경과 질의를 구분해라 라는 말을 따른것.
이렇게 함으로써 추적하기가 쉬워지니까. 

- 메소드만 빼내는 방법에 이어서 여러 함수를 클래스로 묶는 (6.9절) 방법이나 여러 함수를 변환 함수로 묶어서 (6.10절) 변경하는 함수를 제한시켜 놓는 것 이를 통해서 추적하기 쉬워지라고. 

- 변경할 가능성 자체를 줄이는 세터 제거하기 (11.7 절)

- 한 변수가 다른 변수에 의해 생성되는 값이라면 이를 질의함수로 바꿔주는 파생 변수를 질의 함수로 변경하기 (9.3절) 을 이용하는 것 

  - 이는 예측하기가 힘들어서 그런 듯.
  
- 한 객체에 참조를 바꾸는 것보다 그냥 객체 자체를 생성하는 참조를 값으로 바꾸기 기법 (9.4절) 도 있다. 객체 자체가 필요한 경우. 


***

## 3.7 뒤엉킨 변경 (Divergent Change)

너무 큰 맥락으로 인해 이 요구사항으로도 이 객체를 변경해야 하고 그 객체의 변경 포인트가 여러개인 경우. 

원래라면 하나의 객체에 하나의 메소드만 변경하면 되는데. 

이 경우 해결방법은 맥락을 나눠서 적절한 책임을 가진 모듈로 만들어 두는 걸 말한다. 

해결 방법은 다음과 같다. 

- 단계 쪼개기 (6.11절) 을 통해서 맥락을 나눠서 적절한 모듈을 만드는 것.

- 여러 맥락을 드나드는 함수가 있다면 함수 추출하기 (6.1절) 를 통해서 한 맥락에만 관심을 가지는 함수로 바꾸는 것. 

- 만약 맥락이 거대한 클래스라면 클래스 추출하기 (7.5절) 를 통해서 적절한 클래스로 나누는 것. 

***

## 3.8 산탄총 수술 (Shotgun Surgery)

너무나 작은 맥락으로 인해 하나의 요구사항이 들어오면 여러 곳을 고쳐야 하는 문제를 말한다. 

이 기법은 흩어저 있는 코드를 한 곳으로 모아서 적절한 책임을 가진 모듈로 만들어 놓는 방식을 통해서 해결한다. 

해결 방법은 다음과 같다. 

- 함수 옮기기 (8.1절) 와 필드 옮기기 (8.2절) 을 통해서 한 모듈로 만들어주는 것.  

- 여러 함수를 모아서 클래스로 묶기 (6.9절) 을 통해서 한 모듈로 만들어 주는 것.  

- 여러 함수에 맥락이 흩어져 있다면 여러 함수를 변환 함수로 묶기 기법을 통해서 하나의 기능을 가진 함수로 묶어주는 것. 

- 묶은 함수가 다음 맥락까지 가지 않도록 단계 쪼개기 (6.11절) 를 통해 적절한 모듈에서 끊어주는 것. 

***

## 3.9 기능 편애 (Feature Envy)

한 모듈에서 응집도를 높이는 것.

한 모듈에서 내부에서 상호작용이 많도록 하되 한 모듈에서 다른 모듈과의 상호작용이 많은 걸 출이는 것. 

주로 이제 Getter 를 통해서 다른 모듈의 데이터가 필요한 경우가 많을 때 생기는 악취다. 

해결하는 방법은 단순한데 상호작용이 필요한 그 모듈로 옮겨주면 된다. 

- 함수 추출하기 (6.1절) 을 통해서 추출한 후 함수 옮기기 (8.1절) 을 통해서 옮겨주면 된다. 

  - 함수 옮기는 기준은 관련 데이터가 가장 많은 곳으로 옮겨주면 된다. 
  
- 디자인 패턴을 이용하는 방법들도 있다. (전략 패턴, 방문자 패턴)

***

## 3.10 데이터 뭉치 (Data Clumps)

몰려다니는 데이터가 있는데 이를 묶어주지 않는다면 SRP 를 따르지 않게 되고 변경해야하는 코드가 많아지는 악취가 날 수 있다.

메소드에 파라미터로서 몰려다니는 데이터가 있다면 메소드를 이해하기 어려워지는 악취가 날 수 있다.  

그러므로 이를 해결하는 방법은 관련있는 데이터끼리 모아주자. 

- 클래스의 특정 필드끼리 몰려다닌다면 클래스 추출하기 기법 (7.5절) 을 사용해서 묶어주는게 가능하다. 

- 메소드의 파라미터끼리 몰려다닌다면 매개변수를 객체로 만드는 기법 (6.8절) 을 이용할 수 있다. 

- 또 객체의 데이터를 분해해서 메소드에 넣어주는 것이라면 객체 자체를 넘겨주도록 하는 기법인 (11.4절) 을 이용할 수도 있다.

***

## 3.11 기본형 집착 (Primitive Obsession)

기본형만을 고집해서 사용한다면 기본형 데이터를 기반으로 계산하는 로직을 코드로 짜니까 이해하기 어렵다는 악취가 날 수 있다. 

예를들면 if 조건절에서 기본형을 가지고 계산한 식이다. 이 기본형 데이터를 클래스로 감싸고 메소드를 통해서 표현하면 훨씬 간단하게 표현할 수도 있는데. 

이를 해결하는 방법은 간단하다. 기본형을 클래스로 감싸서 추상화를 하는 것이다. 

- 기본적으로는 기본형을 클래스로 감싸서 문명화를 시키는 것이다. 이는 클래스 추출하기 기법을 통해서 이뤄진다. (7.5절)

- 이 외에 응용으로 타입코드를 서브 클래스로 바꾸기 기법이 있을 것이고 (12.6절)

- 조건부 로직을 다형성으로 바꾸기 (10.4절) 로 좀 더 간단하게 표현하는게 가능하다. 

***

## 3.12 반복되는 Switch 문 

중복되는 Switch 문은 악취가 심하다. 이것도 뭐 변경포인트가 많아지는 악취지.  

최악의 경우 딱 하나의 Switch 문만 허용된다. 

이를 해결하는 방법은 Switch 문의 중복을 제거하는 것이다. 

- 조건부 로직을 다형성을 통해서 해결하는 기법을 통해서 해결할 수 있다. (10.4절)

***

## 3.13 반복문 (Loops)

복잡한 반복문은 무슨 일을 하는지 파악하기 어렵다. 이와 관련된 악취다.

일반적으로 반복문은 반복문 안의 코드가 한 줄 일때 이해하기 쉽다.

반복문을 해결하는 방법은 간단하다. 

- 반복문 안에서 실핸하는 코드를 한 줄로 줄인다.

- 반복문 대신에 파이프라이능ㄹ 사용하도록 한다. (8.8절)

***

## 3.14 성의 없는 요소 (Lazy Element)

사용하지 않는 필요없는 코드는 지우는게 좋다. 괜히 남아있으면 오해만 일으키므로. 이와 관련된 악취다.

해결하는 기법은 간단하다.

- 함수를 인라인 하는 기법으로 함수를 제거할 수 있다. (6.2절)

- 클래스를 인라인해서 클래스를 제거할 수 있다. (7.6절)

- 상속을 사용했다면 계층 합치기를 통해서 하위 클래스를 위임으로 바꾸는 걸 사용하면 된다. (12.9절)

***

## 3.15 추측성 일반화 (Speculative Generality)

추측성 일반화는 먼 확장성을 고려해서 지금의 코드베이스를 망취는 악취다. (YAGNI)

이를 해결하는 기법은 간단하다. 

- 하는 일이 거의 없는 클래스는 계층 합치기 (12.9절) 을 통해서 함치면 된다. 

- 클래스와 함수를 모두 인라인해서 제거하면 된다. 

- 안쓰는 코드는 지우는 죽은 코드 제거하기 기법 (8.9절) 을 이용하면 된다. 

***

## 3.16 임시 필드 (Temporary Field)

간혹 클래스의 필드를 모두 사용하지 않고 특정한 상황에서만 사용하는 필드가 있다면 이는 이해하기 어려운 클래스이므로 악취를 불러일으킨다. 

원래 클래스라는 것 자체가 모든 필드가 다 들어있다는 전제하에 객체를 만들기 때문이다. 

그러므로 이를 해결하는 기법은 간단하다.

- 이런 임시 필드가 있다면 이를 따로 뽑아서 클래스로 추출해서 제 살길을 찾아줘야한다. (7.5절)

  - 그 다음 임시 필드와 관련있는 함수들을 모두 옮겨주자. (8.1절)
  
- 임시 필드와 관련된 동작을 하는 경우가 있었다면 이를 모두 특이 케이스라는 클래스를 통해서 해결하도록 하자. (10.5절)

***

## 3.17 메시지 체인 (Message Chain)

디미터 법칙을 어기는 메시지 체인은 결합도를 높이는 문제점이 있다. 

즉 다른 모듈에 의존하는 경향이 높아지는 악취를 풍긴다.

클래스는 필요할 때만 협력을 하고 스스로 처리할 수 있는 응집도가 있어야 한다.

이를 해결하는 기법은 간단하다. 결합도를 낮춰야한다.

- 위임 숨기기 (7.7절) 을 통해서 중재자를 만들어서 결합도를 낮출 수 있다. 

- 결국 그 최종 객체에게 어떠한 행동을 바라는지 살펴보고 이 행동을 추출하고 옮겨야 한다. 

  - 함수 추출하기 (6.1절)
  
  - 함수 옮기기 (8.1절)
  
***

## 3.18 중개자 (Middle Name)

객체가 다른 객체를 직접 호출하는 구조가 아닌 대신 호출해주는 중개자 객체가 있고 이게 그렇게 필요한 객체가 아니라면 악취가 난다.

필요가 없는 객체가 있으므로 이해하기 어려운 악취의 종류.

물론 다른 객체가 대신 호출해주면 좋은 경우가 있다. (프록시 패턴과 같은 경우)

이를 해결하는 방법은 중개자 객체를 제거해줘야한다. 

- 중개자 제거하기 기법 (7.8절) 을 통해서 제거하도록 하자.

***

## 3.19 내부자 거래 (Insider Training)

모듈사이에 은밀한 결합이 있다면 이를 제거해야한다. 

결합도를 낮추고 응집도를 높여야 하는 종류의 악취다. 

이를 해결하는 기법은 결합도를 낮추는 종류의 기법이다.

- 필드 옮기기 (8.2절) 함수 옮기기 (8.1절) 을 통해서 적절한 모듈이 결합없이 처리하도록 하자. 

- 여러 모듈이 같은 관심사를 공유해서 결합하는 일이 많다면 제 3의 모듈을 만들거나 위임 숨기기 (7.7) 기법을 이용하자. 

- 상속 구조에서 부모와 자식간의 결합이 많다면 위임으로 바꿔야한다. 이는 서브 클래스를 위임으로 바꾸기 (12.10절) 이나 부모 클래스를 위임으로 바꾸기 (12.11절) 을 이용하면 된다.

__(결합은 협력과는 다르다. 협력은 서로가 하는일을 적절하게 맡아서 처리하는 느낌이라면 결합은 너의 데이터가 좀 필요한 경우? 라고 생각하면 될까?)__

***

## 3.20 거대한 클래스 

거대한 클래스는 많은 역할을 가질 확률이 높고 중복된 코드르 가질 확률도 높다. 

즉 이런 종류의 악취를 풍긴다.

이를 해결하는 방법은 쉽다. 클래스 크기를 줄여야 한다. 

- 필드를 모아 클래스 추출을 통해서 클래스 크기를 줄일 수 있다. (7.5절)

  -  접두어가 같은 클래스끼리 모운다고 생각하면 된다. 
  
- 여러 클래스들 사이에서 공통의 속성이 있을 것 같거나 계층을 이루는 클래스라면 슈퍼 클래스 추출하기 (12.8절) 을 통해서 추출하는게 가능하다.

- 타입 코드가 있다면 이를 이용해 서브 클래스 추출하기로 나눌 수도 있겠다. (12.6절)

- 또 중복된 메소드가 많다면 함수 추출하기를 통해서 제거하자 (6.1절)

***

## 3.21 서로 다른 인터페이스의 대안 클래스들 (Alternative Classes with Different Interfaces)

역할에 의존하도록 하고 구현체에 의존하지 않도록 함으로써 DIP 와 OCP 를 지킴으로써 향기를 불러일으킬 수 있다. 

서로 비슷한 기능인데 인터페이스가 다르다면 인터페이스를 통일시켜서 이를 해결할 수 있다.

- 함수 선언 바꾸기 (6.5절) 을 통해서 메소드를 변경해서 하나의 인터페이스로 통일하게 만들 수 있다. 

  - 이 과정에서 함수를 옮겨야 할 수 있다. (8.1절)
  
- 대안 클래스들 사이에서 중복 코드가 생긴다면 이를 슈퍼 클래스로 옮겨서 이를 해결할 수도 있다. (12.8절)

***

## 3.22 데이터 클래스 (Data Class)

Getter/Setter 만 있는 클래스는 그 자체로 협력할 수 없고 다른 클래스가 마음대로 사용할 가능성이 크다. 

결합도가 높아지고 SRP 를 위반하는 악취를 불러일으킬 수 있다. 

예외적으로 데이터 클래스를 사용하는 경우가 있는데 이는 단계 쪼개기 (6.11절) 의 중간 결과로서 사용되는 경우다. 

이를 해결하는 방법은 데이터 클래스를 적절한 역할을 가지도록 해주는 것이다. 

- 함수 옮기기 (8.1절) 나 다른 클래스들에 있는 함수 추출하기 (6.1절) 를 통해서 이 클래스의 역할을 잡아주도록 하면 된다. 

***

## 3.23 상속 포기하기 (Refused Bequest)

자식 클래스가 부모 클래스의 인터페이스를 따르지 않는다면 LSP 를 따르지 않는 것이므로 악취를 불러일으킨다. 

물론 자식이 부모 클래스의 모든 인터페이스를 따르지만 단지 한 두개가 핑요 없는 경우라면 메소드 내리기 기법 (12.4절) 과 필드 내리기 (12.5절) 을 통해서 해결하는게 가능하다./

이를 해결하는 방법은 간단하다. 상속 관계로 바꾸는게 아니라 위임으로 바꾸는 것이다.

- 서브 클래스를 위임으로 바꾸기 (12.10절) 을 통하거나 슈퍼 클래스를 위임으로 바꾸기 (12.11절) 을 통해서 가능하다. 

***

## 3.24 주석 (Comments)

주석을 사용할려면 올바르게 사용하자.

- 좋은 주석은 정보를 제공해주거나 코드의 의도를 설명해주는 주석, 의미를 명료하게 밝히느 주석 등이 있다. 

잘못된 주석의 사용은 악취를 불러 일으킨다.

- 예로 장황한 설명을 하거나, 있으나 마나한 주석이 있다. 

이를 해결하는 방법은 주석을 사용하기전에 리팩토링을 진행해보는 것이다. 











